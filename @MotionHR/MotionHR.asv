classdef MotionHR
    
    % MOTIONHR Collection of functions for processing Heart rate and IMU data. 
    
    %
    %   Author: S.Hemminki
    %   All rights reserved.
    %
    %   Date: 19/09/2017
    %   Ver: 0.9
    %
    
    properties(Constant)
       
        DataIndex =                                  ...
            struct('ts',            1,               ...
                   'accX',          2,               ...
                   'accY',          3,               ...
                   'accZ',          4,               ...
                   'gyroX',         5,               ...
                   'gyroY',         6,               ...
                   'gyroZ',         7,               ...
                                                     ...
                   'accel',         2:4,             ...
                   'gyro',          5:7,             ...
                   'accelWithTime', 1:4,             ...
                   'gyroWithTime',  [1, 5:7]); 
               
        HRConstants =                                ...
            struct('ts',            1,               ...
                   'HR_BPM',        2);
               
        RESAMPLE_RATE = 50;
        
    end
    
    properties
        
        % Offsets for HR monitors
        polarOffset  = -1;
        fitbitOffset = -1;
        
        % Data
        MotionData;
        HRData;
        
        % Motion data 
        resamplingInterval;
        
        % Gravity Estimation
        initG;
        
    end
    
    methods
        
        % Empty constructor
        function obj = MotionHR()
        end
        
        % Parse from RawFolder
        function obj = parseFromRaw(obj, url)
           
            files = dir( [url, '\*.csv'] );
            
            for i=1:length(files)
               
                thisFile = files(i).name;
                
                if contains(thisFile, 'acc')
                    % Not required, since acc comes with gyro
                end
                
                if contains(thisFile, 'gyr')
                    
                    accgyro = dlmread(thisFile, ';');
                    
                    % Gyro is is degrees/sec, should be rad/sec
                    accgyro(:, obj.DataIndex.gyro) = deg2rad(accgyro(:, obj.DataIndex.gyro));
                    
                    % Move timestamps from ms --> sec
                    accgyro(:, obj.DataIndex.ts) = accgyro(:, obj.DataIndex.ts) / 1e3;
                    
                    % Resample motion sensors at constant 50hz
                    data = accgyro(:, [obj.DataIndex.accel, obj.DataIndex.gyro]);
                    time = accgyro(:, obj.DataIndex.ts);
                    [rs_data, rs_ts] = resample(data, time, obj.RESAMPLE_RATE);
                    cleanData = [rs_ts, rs_data];
                    
                    % Insert into MotionHR
                    obj = obj.addMotionData(cleanData);
                    
                end
                
                if contains(thisFile, 'hr_band')
                    obj = obj.addHRData(dlmread(thisFile, ';'), 'band2');
                end
                
                if contains(thisFile, 'hr_fitbit')
                    obj = obj.parseFitbitOffset(thisFile);
                    obj = obj.addHRData(readtable(thisFile), 'fitbit');
                end
                
                if contains(thisFile, 'hr_polar')
                    obj = obj.parsePolarOffset(thisFile);
                    obj = obj.addHRData(readtable(thisFile), 'polar');
                end
                
                if contains(thisFile, 'rr_band2')
                    % Not used for now
                end
                
            end
            
        end
        
        % Pipeline
        function obj = runPipeline(obj, motionData, band2, fitbit, polar)
           
            obj.MotionData = [];
            obj.HRData = [];
           
            % Resampling interval as median of dtime between samples
            obj.resamplingInterval = median( diff(motionData(:,1)) );
            
            obj = obj.addMotionData(motionData);
            obj = obj.addHRData(band2,'band2');
            obj = obj.addHRData(fitbit,'fitbit');
            obj = obj.addHRData(polar,'polar');
            obj = obj.compareMotionWithHR;
           
        end
        
        % Add motiondata
        function obj = addMotionData(obj, input)
            
            median_dtime = median(diff(input(:, obj.DataIndex.ts)));
            
            if median_dtime > 1
                disp('Warning: Timestamp not in seconds!');
            end
            
            % Add timezone offset
            input(:, obj.DataIndex.ts) = input(:, obj.DataIndex.ts)+3600*3;
            
            obj.MotionData = input;
        end
        
        % Add HR rata from provider
        function obj = addHRData(obj, data, provider)
            
            switch(provider)
                case('polar')
                    parsedData = obj.parsePolar(data);
                    
                case('fitbit')
                    parsedData = obj.parseFitbit(data);

                case('band2')
                    parsedData(:, obj.HRConstants.ts)     = data(:, obj.HRConstants.ts) ./ 1e3 + 3600 * 3; % Add timezone offset
                    parsedData(:, obj.HRConstants.HR_BPM) = data(:, obj.HRConstants.HR_BPM);
            end
 
            obj.HRData.(provider) = parsedData;
        end
        
        % Compare HR with Motion
        function obj = compareMotionWithHR(obj)
           
            % Align HR with Motion
            if isempty(obj.MotionData) || isempty(obj.HRData)
                disp('MotionData and/or HRData not initialised!');
                return;
            end

            aligned  = obj.MotionData;
            [obj, G] = obj.getFusionGrav(aligned);

            HRDataTypes = fieldnames(obj.HRData);
            for i=1:length(HRDataTypes)
                aligned = alignTimeseries(aligned,obj.HRData.(HRDataTypes{i}));
            end
            
            
            
            
            
        end

    end
        
    methods (Access = private)
        
        % Parse offset time for Polar input table
        function obj = parsePolarOffset(obj, input)
            
            % Load data from the file
            fid = fopen(input);
            % nLines = countLines(fid);
            % lines = cell(nLines,1);
            line = 'first';
            i=1;
            while ischar(line) && i < 3
                line = fgetl(fid);
                if ischar(line)
                    headerLines{i} = line;
                end
                i = i+1;
            end
            fclose(fid);
            
             % This contains the start time
            strSplits = strsplit(headerLines{2}, ',');
            date  = strSplits{3};
            time = strSplits{4};
            
            obj.polarOffset = posixtime(datetime([date, ' ', time], 'InputFormat', 'dd-MM-yyyy HH:mm:ss'));
            
        end
        
        % Parse offset time from fileName for Fitbit
        function obj = parseFitbitOffset(obj, input)
            
            % Parse from input filename
            strSplits = strsplit(input,'_');
            year      = strSplits{1}(1:4);
            month     = strSplits{1}(5:6);
            day       = strSplits{1}(7:8);
            
            obj.fitbitOffset = posixtime(datetime(['', year, '-', month, '-', day, ' 00:00:00']));
            
        end
        
        % Parse HR data from Polar format
        function data = parsePolar(obj, input)
        
            ts = input.Time;
            
            for i=1:length(ts)
                tsSplits = strsplit(ts{i},':');
                
                tsInSeconds = str2num(tsSplits{1})*3600   + ...
                              str2num(tsSplits{2})*60     + ...
                              str2num(tsSplits{3}); 
                             
                tsUTC(i) = tsInSeconds + obj.polarOffset;
                
            end

            data(:,obj.HRConstants.ts) = tsUTC;
            data(:,obj.HRConstants.HR_BPM) = input.HR_bpm_;
            
        end
        
        % Parse HR data from Fitbit format
        function data = parseFitbit(obj, input)
            
            ts = input.Time;
            
            for i=1:length(ts)
                tsSplits = strsplit(ts{i},':');
                
                tsInSeconds = str2num(tsSplits{1})*3600   + ...
                              str2num(tsSplits{2})*60     + ...
                              str2num(tsSplits{3}); 
                             
                tsUTC(i) = tsInSeconds + obj.fitbitOffset;
                
            end
            
            data(:,obj.HRConstants.ts) = tsUTC;
            data(:,obj.HRConstants.HR_BPM) = input.HeartRate_beats_min_;
            
        end
        
        % Gravity Estimation using DCM
        function [ obj, G ] = getFusionGrav(obj,data)
            
            % Get initG or initialize with first measurement if empty
            if isempty(obj.initG)
                obj.initG = data(1,2:4);
            end
            
            % Parameters
            samplingFreq = round(1/obj.resamplingInterval);
            base_wAccel  = 0.25/samplingFreq;
            C            = 0.1/samplingFreq;

            gNorm        = 1;
            
            % Extract Data
            accel       = data(:,2:4);
            gyro        = data(:,5:7);
            
            % Preallocate & Initialize
            backpropagate = 0;
            frameNr     = size(accel,1);
            G           = zeros(size(accel));
            gyroG       = zeros(size(accel));
            gyroG(1,:)  = obj.initG;
            G(1,:)      = obj.initG;
            
            % Loop through data
            for i=2:frameNr
                
                gyro(i,:) = gyro(i,:) .* obj.resamplingInterval;
                
                % Rotation Matrix
                rotMatrix = [1 -gyro(i,3) gyro(i,2); ...
                    gyro(i,3) 1 -gyro(i,1); ...
                    -gyro(i,2) gyro(i,1) 1];
                
                gyroG(i,:) = G(i-1,:) * rotMatrix;
                
                % Renormalize if over 10% off from expected G
                if getMagnitude(gyroG(i,:))>(gNorm*1.1)
                    normalizer = getMagnitude(gyroG(i,:))/gNorm;
                    gyroG(i,:) = gyroG(i,:) ./  normalizer;
                end
                
                % Adjust accel weight (TODO)
                wAccel = base_wAccel;
                
                % Nudge to handle small accel - G distances
                deltaG = accel(i,:) - gyroG(i,:);
                nudge = sign(deltaG).*[C,C,C];
              
                for ax=1:3
                    if abs(deltaG(ax))>abs(nudge(ax))
                        G(i,ax) = (1-wAccel)*gyroG(i,ax) + wAccel*accel(i,ax) + nudge(ax);
                    else
                        G(i,ax) = (1-wAccel)*gyroG(i,ax) + wAccel*accel(i,ax);
                    end
                    
                end  
            end
            
            obj.initG = G(end,:);
        end
        
        
    end
    
end

